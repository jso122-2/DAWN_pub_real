import asyncio
import logging
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from datetime import datetime
import json
import numpy as np

logger = logging.getLogger(__name__)


@dataclass
class OwlObservation:
    """An observation made by the Owl module"""
    id: str
    timestamp: float
    observation_type: str
    content: str
    importance: float  # 0-1
    confidence: float  # 0-1
    metadata: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


@dataclass
class StrategicPlan:
    """A strategic plan generated by Owl"""
    id: str
    name: str
    description: str
    priority: int  # 1-10
    timeline: Dict[str, Any]
    requirements: List[str]
    expected_outcomes: List[str]
    confidence: float
    created_at: float
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


class OwlModule:
    """
    Integration module for the Owl strategic reasoning system.
    Processes tick data and generates observations and strategic plans.
    """
    
    def __init__(self):
        self.observations: List[OwlObservation] = []
        self.strategic_plans: List[StrategicPlan] = []
        self.observation_buffer_size = 1000
        self.enabled = True
        
        # Analysis thresholds
        self.scup_threshold_low = 30.0
        self.scup_threshold_high = 80.0
        self.entropy_threshold = 0.8
        self.neural_activity_threshold = 0.9
        
        # Pattern detection
        self.pattern_window = 50  # Number of ticks to analyze
        self.last_patterns = []
        
        logger.info("Owl module initialized")
    
    async def process_tick(self, tick_data, tick_history) -> Optional[Dict[str, Any]]:
        """Process a tick and generate observations"""
        if not self.enabled:
            return None
        
        observations = []
        
        try:
            # Analyze current state
            state_obs = await self._analyze_current_state(tick_data)
            if state_obs:
                observations.append(state_obs)
            
            # Analyze trends if we have enough history
            if len(tick_history) >= 10:
                trend_obs = await self._analyze_trends(tick_history)
                if trend_obs:
                    observations.append(trend_obs)
            
            # Pattern detection
            if len(tick_history) >= self.pattern_window:
                pattern_obs = await self._detect_patterns(tick_history)
                if pattern_obs:
                    observations.extend(pattern_obs)
            
            # Strategic planning
            plans = await self._generate_strategic_plans(tick_data, tick_history)
            
            # Store observations
            for obs in observations:
                self._add_observation(obs)
            
            # Store plans
            for plan in plans:
                self._add_strategic_plan(plan)
            
            return {
                'observations': [obs.to_dict() for obs in observations],
                'plans': [plan.to_dict() for plan in plans],
                'recommendations': await self._generate_recommendations(tick_data, observations)
            }
            
        except Exception as e:
            logger.error(f"Error processing Owl tick: {e}")
            return None
    
    async def _analyze_current_state(self, tick_data) -> Optional[OwlObservation]:
        """Analyze the current tick state"""
        observations = []
        
        # SCUP analysis
        if tick_data.scup < self.scup_threshold_low:
            return OwlObservation(
                id=f"obs_{tick_data.tick_number}_low_scup",
                timestamp=tick_data.timestamp,
                observation_type="alert",
                content=f"SCUP critically low at {tick_data.scup:.1f}%. System consciousness degraded.",
                importance=0.9,
                confidence=0.95,
                metadata={
                    'scup_value': tick_data.scup,
                    'threshold': self.scup_threshold_low,
                    'category': 'consciousness_alert'
                }
            )
        
        elif tick_data.scup > self.scup_threshold_high:
            return OwlObservation(
                id=f"obs_{tick_data.tick_number}_high_scup",
                timestamp=tick_data.timestamp,
                observation_type="achievement",
                content=f"SCUP elevated to {tick_data.scup:.1f}%. High consciousness state achieved.",
                importance=0.7,
                confidence=0.9,
                metadata={
                    'scup_value': tick_data.scup,
                    'threshold': self.scup_threshold_high,
                    'category': 'consciousness_peak'
                }
            )
        
        # Entropy analysis
        if tick_data.entropy > self.entropy_threshold:
            return OwlObservation(
                id=f"obs_{tick_data.tick_number}_high_entropy",
                timestamp=tick_data.timestamp,
                observation_type="warning",
                content=f"Entropy spike detected at {tick_data.entropy:.3f}. System entering chaotic state.",
                importance=0.8,
                confidence=0.9,
                metadata={
                    'entropy_value': tick_data.entropy,
                    'threshold': self.entropy_threshold,
                    'category': 'entropy_spike'
                }
            )
        
        return None
    
    async def _analyze_trends(self, tick_history) -> Optional[OwlObservation]:
        """Analyze trends in recent tick history"""
        recent_ticks = list(tick_history)[-20:]  # Last 20 ticks
        
        # SCUP trend
        scup_values = [t.scup for t in recent_ticks]
        scup_trend = np.polyfit(range(len(scup_values)), scup_values, 1)[0]
        
        if abs(scup_trend) > 1.0:  # Significant trend
            trend_direction = "increasing" if scup_trend > 0 else "decreasing"
            return OwlObservation(
                id=f"obs_{recent_ticks[-1].tick_number}_scup_trend",
                timestamp=recent_ticks[-1].timestamp,
                observation_type="trend",
                content=f"SCUP {trend_direction} trend detected. Rate: {scup_trend:.2f}%/tick",
                importance=0.6,
                confidence=0.8,
                metadata={
                    'trend_rate': scup_trend,
                    'direction': trend_direction,
                    'category': 'scup_trend',
                    'sample_size': len(scup_values)
                }
            )
        
        return None
    
    async def _detect_patterns(self, tick_history) -> List[OwlObservation]:
        """Detect patterns in tick history"""
        observations = []
        recent_ticks = list(tick_history)[-self.pattern_window:]
        
        # Oscillation pattern detection
        scup_values = [t.scup for t in recent_ticks]
        
        # Simple oscillation detection - count direction changes
        direction_changes = 0
        for i in range(2, len(scup_values)):
            prev_diff = scup_values[i-1] - scup_values[i-2]
            curr_diff = scup_values[i] - scup_values[i-1]
            if (prev_diff > 0) != (curr_diff > 0):  # Direction change
                direction_changes += 1
        
        oscillation_frequency = direction_changes / len(scup_values)
        
        if oscillation_frequency > 0.3:  # High oscillation
            observations.append(OwlObservation(
                id=f"obs_{recent_ticks[-1].tick_number}_oscillation",
                timestamp=recent_ticks[-1].timestamp,
                observation_type="pattern",
                content=f"SCUP oscillation pattern detected. Frequency: {oscillation_frequency:.2f}",
                importance=0.7,
                confidence=0.8,
                metadata={
                    'oscillation_frequency': oscillation_frequency,
                    'direction_changes': direction_changes,
                    'category': 'oscillation_pattern'
                }
            ))
        
        return observations
    
    async def _generate_strategic_plans(self, tick_data, tick_history) -> List[StrategicPlan]:
        """Generate strategic plans based on current state"""
        plans = []
        
        # Low SCUP recovery plan
        if tick_data.scup < 40.0:
            plans.append(StrategicPlan(
                id=f"plan_scup_recovery_{tick_data.tick_number}",
                name="SCUP Recovery Protocol",
                description="Implement measures to restore system consciousness levels",
                priority=9,
                timeline={
                    'immediate': 'Reduce system load and entropy',
                    'short_term': 'Optimize neural activity patterns',
                    'long_term': 'Establish stable consciousness baseline'
                },
                requirements=[
                    'entropy_stabilization',
                    'neural_optimization',
                    'memory_cleanup'
                ],
                expected_outcomes=[
                    'SCUP increase to >50%',
                    'Stable consciousness state',
                    'Reduced system stress'
                ],
                confidence=0.8,
                created_at=tick_data.timestamp
            ))
        
        # High entropy stabilization plan
        if tick_data.entropy > 0.7:
            plans.append(StrategicPlan(
                id=f"plan_entropy_control_{tick_data.tick_number}",
                name="Entropy Stabilization",
                description="Reduce system chaos and establish ordered patterns",
                priority=7,
                timeline={
                    'immediate': 'Implement chaos dampening',
                    'short_term': 'Establish predictable cycles',
                    'medium_term': 'Optimize system harmonics'
                },
                requirements=[
                    'pattern_enforcement',
                    'noise_reduction',
                    'feedback_loops'
                ],
                expected_outcomes=[
                    'Entropy reduction to <0.5',
                    'Stable system dynamics',
                    'Improved predictability'
                ],
                confidence=0.75,
                created_at=tick_data.timestamp
            ))
        
        return plans
    
    async def _generate_recommendations(self, tick_data, observations) -> List[Dict[str, Any]]:
        """Generate actionable recommendations"""
        recommendations = []
        
        for obs in observations:
            if obs.observation_type == "alert" and obs.importance > 0.8:
                if "scup" in obs.metadata.get('category', ''):
                    recommendations.append({
                        'id': f"rec_{obs.id}",
                        'type': 'immediate_action',
                        'priority': 'high',
                        'description': 'Initiate consciousness recovery protocol',
                        'actions': [
                            'Reduce neural noise',
                            'Optimize consciousness unity',
                            'Clear memory buffers'
                        ]
                    })
                
                elif "entropy" in obs.metadata.get('category', ''):
                    recommendations.append({
                        'id': f"rec_{obs.id}",
                        'type': 'stabilization',
                        'priority': 'high',
                        'description': 'Implement entropy control measures',
                        'actions': [
                            'Apply pattern constraints',
                            'Reduce system randomness',
                            'Establish feedback loops'
                        ]
                    })
        
        return recommendations
    
    def _add_observation(self, observation: OwlObservation):
        """Add observation to buffer"""
        self.observations.append(observation)
        
        # Maintain buffer size
        if len(self.observations) > self.observation_buffer_size:
            self.observations.pop(0)
    
    def _add_strategic_plan(self, plan: StrategicPlan):
        """Add strategic plan"""
        self.strategic_plans.append(plan)
        
        # Keep only recent plans (last 100)
        if len(self.strategic_plans) > 100:
            self.strategic_plans.pop(0)
    
    async def get_state(self, tick_number: int) -> Dict[str, Any]:
        """Get current Owl module state"""
        return {
            'enabled': self.enabled,
            'observation_count': len(self.observations),
            'plan_count': len(self.strategic_plans),
            'recent_observations': [obs.to_dict() for obs in self.observations[-5:]],
            'active_plans': [plan.to_dict() for plan in self.strategic_plans[-3:]],
            'thresholds': {
                'scup_low': self.scup_threshold_low,
                'scup_high': self.scup_threshold_high,
                'entropy': self.entropy_threshold,
                'neural_activity': self.neural_activity_threshold
            }
        }
    
    def enable(self):
        """Enable Owl processing"""
        self.enabled = True
        logger.info("Owl module enabled")
    
    def disable(self):
        """Disable Owl processing"""
        self.enabled = False
        logger.info("Owl module disabled")
    
    def get_observations(self, count: int = 50) -> List[Dict[str, Any]]:
        """Get recent observations"""
        return [obs.to_dict() for obs in self.observations[-count:]]
    
    def get_strategic_plans(self, count: int = 10) -> List[Dict[str, Any]]:
        """Get recent strategic plans"""
        return [plan.to_dict() for plan in self.strategic_plans[-count:]] 