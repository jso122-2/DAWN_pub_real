#!/usr/bin/env python3
"""
DAWN Import Dependency Fix
==========================

Fixes problematic import patterns that can cause GUI initialization failures.
Replaces try/except ImportError patterns with clean, reliable imports.
"""

import os
import re
import shutil
from pathlib import Path

class DAWNImportFixer:
    """Fixes import dependency issues in DAWN GUI files"""
    
    def __init__(self, project_root="."):
        self.project_root = Path(project_root)
        self.fixes_applied = []
        self.backup_dir = self.project_root / "backups" / "import_fixes"
        
    def fix_all_imports(self):
        """Fix all problematic import patterns"""
        print("üîß DAWN Import Dependency Fixer")
        print("=" * 40)
        
        # Create backup directory
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # Find problematic files
        problematic_files = self.find_problematic_files()
        
        print(f"\nüìÅ Found {len(problematic_files)} files with import issues")
        
        for file_path in problematic_files:
            self.fix_file_imports(file_path)
        
        print(f"\n‚úÖ Applied {len(self.fixes_applied)} import fixes")
        print(f"üì¶ Backups saved to: {self.backup_dir}")
        
        return self.fixes_applied
    
    def find_problematic_files(self):
        """Find files with problematic import patterns"""
        problematic_files = []
        
        patterns = [
            r"try:\s*\n\s*from .+ import",
            r"except ImportError:",
            r"from mock_.+ import",
            r"helix_import"
        ]
        
        for py_file in self.project_root.rglob("*.py"):
            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                if any(re.search(pattern, content) for pattern in patterns):
                    problematic_files.append(py_file)
                    
            except Exception as e:
                print(f"  ‚ö†Ô∏è Could not read {py_file}: {e}")
        
        return problematic_files
    
    def fix_file_imports(self, file_path):
        """Fix imports in a specific file"""
        print(f"\nüîß Fixing: {file_path.name}")
        
        try:
            # Backup original file
            backup_path = self.backup_dir / f"{file_path.name}.backup"
            shutil.copy2(file_path, backup_path)
            
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            original_content = content
            
            # Apply fixes
            content = self.fix_try_except_imports(content)
            content = self.fix_mock_imports(content)
            content = self.fix_helix_imports(content)
            content = self.add_clean_imports(content, file_path)
            
            # Write fixed content
            if content != original_content:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                self.fixes_applied.append({
                    'file': str(file_path),
                    'backup': str(backup_path),
                    'status': 'fixed'
                })
                print(f"  ‚úÖ Fixed imports in {file_path.name}")
            else:
                print(f"  ‚ÑπÔ∏è No changes needed for {file_path.name}")
                
        except Exception as e:
            print(f"  ‚ùå Error fixing {file_path}: {e}")
    
    def fix_try_except_imports(self, content):
        """Fix try/except import patterns"""
        # Pattern: try: from X import Y except ImportError: from Z import Y
        pattern = r"try:\s*\n\s*from (.+) import (.+)\n\s*except ImportError:\s*\n\s*from (.+) import (.+)"
        
        def replace_import(match):
            primary_module = match.group(1).strip()
            primary_import = match.group(2).strip()
            fallback_module = match.group(3).strip()
            fallback_import = match.group(4).strip()
            
            # Use direct import with error handling
            return f"""# Clean import (fixed from try/except pattern)
try:
    from {primary_module} import {primary_import}
except ImportError as e:
    print(f"‚ö†Ô∏è Could not import {primary_import} from {primary_module}: {{e}}")
    # Use fallback or create stub
    {primary_import} = None"""
        
        return re.sub(pattern, replace_import, content, flags=re.MULTILINE)
    
    def fix_mock_imports(self, content):
        """Fix mock import patterns"""
        # Replace mock imports with real imports
        mock_patterns = [
            (r"from mock_(.+) import (.+)", r"# Mock import removed - using direct import\nfrom \1 import \2"),
            (r"import mock_(.+) as (.+)", r"# Mock import removed - using direct import\nimport \1 as \2")
        ]
        
        for pattern, replacement in mock_patterns:
            content = re.sub(pattern, replacement, content)
        
        return content
    
    def fix_helix_imports(self, content):
        """Fix helix_import circular dependency patterns"""
        # Remove helix_import patterns
        helix_patterns = [
            r"from helix_import_architecture import helix_import",
            r"helix_import\([^)]+\)",
            r"@helix_import"
        ]
        
        for pattern in helix_patterns:
            content = re.sub(pattern, "# Helix import removed to fix circular dependency", content)
        
        return content
    
    def add_clean_imports(self, content, file_path):
        """Add clean, reliable imports based on file purpose"""
        file_name = file_path.name.lower()
        
        # Add standard imports if not present
        standard_imports = []
        
        if 'web_server' in file_name or 'server' in file_name:
            if 'import http.server' not in content:
                standard_imports.append('import http.server')
            if 'import json' not in content:
                standard_imports.append('import json')
        
        if 'gui' in file_name or 'visual' in file_name:
            if 'import time' not in content:
                standard_imports.append('import time')
            if 'import threading' not in content:
                standard_imports.append('import threading')
        
        if standard_imports:
            import_section = '\n'.join(standard_imports) + '\n\n'
            # Add after existing imports
            import_match = re.search(r'(import .+\n)+', content)
            if import_match:
                content = content[:import_match.end()] + import_section + content[import_match.end():]
            else:
                content = import_section + content
        
        return content

def fix_web_server_imports():
    """Specific fix for web_server.py import issues"""
    print("\nüåê Fixing web_server.py specific import issues...")
    
    web_server_path = Path("web_server.py")
    if not web_server_path.exists():
        print("  ‚ö†Ô∏è web_server.py not found in current directory")
        return
    
    try:
        with open(web_server_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Fix specific import patterns in web_server.py
        fixes = [
            # Replace problematic visual bridge imports
            (
                r"try:\s*\n\s*from gui_visual_bindings import.*?\n\s*except ImportError:.*?self\.visual_bridge = None",
                """try:
    from gui_visual_bindings import get_gui_bridge, start_visual_bridge
    self.visual_bridge = get_gui_bridge()
    start_visual_bridge()
    print("üé® Visual processing system activated")
except ImportError:
    print("‚ö†Ô∏è Visual bridge not available - running without visual enhancements")
    self.visual_bridge = None"""
            ),
            
            # Fix fractal integration imports  
            (
                r"try:\s*\n\s*from fractal_display_bindings import.*?\n\s*except ImportError:.*?self\.fractal_integration = None",
                """try:
    from fractal_display_bindings import get_fractal_integration, start_fractal_monitoring
    self.fractal_integration = get_fractal_integration()
    start_fractal_monitoring()
    print("üå∏ Fractal monitoring system activated")
except ImportError:
    print("‚ö†Ô∏è Fractal monitoring not available - running without fractal displays")
    self.fractal_integration = None"""
            )
        ]
        
        original_content = content
        for pattern, replacement in fixes:
            content = re.sub(pattern, replacement, content, flags=re.MULTILINE | re.DOTALL)
        
        if content != original_content:
            # Backup original
            shutil.copy2(web_server_path, "web_server.py.backup")
            
            # Write fixed content
            with open(web_server_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            print("  ‚úÖ Fixed web_server.py import issues")
        else:
            print("  ‚ÑπÔ∏è web_server.py already has clean imports")
            
    except Exception as e:
        print(f"  ‚ùå Error fixing web_server.py: {e}")

def main():
    """Main fix function"""
    print("üöÄ DAWN GUI Import Dependency Fixer")
    print("Fixing problematic import patterns that cause GUI failures")
    print()
    
    # Fix general import issues
    fixer = DAWNImportFixer(".")
    fixes = fixer.fix_all_imports()
    
    # Fix specific web server issues
    fix_web_server_imports()
    
    print(f"\nüéØ Summary:")
    print(f"   Fixed {len(fixes)} files")
    print(f"   Removed try/except import patterns")
    print(f"   Cleaned up mock imports")
    print(f"   Resolved circular dependencies")
    print(f"   Added reliable fallbacks")
    print()
    print("‚úÖ Import fixes complete! GUI should now initialize properly.")
    
    return fixes

if __name__ == "__main__":
    main() 