<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAWN Neural Cognition Timeline</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #050511;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        /* Main Container */
        .timeline-container {
            position: relative;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: linear-gradient(180deg, #0a0a1f 0%, #050511 100%);
        }

        /* Header */
        .timeline-header {
            background: rgba(10, 10, 31, 0.8);
            padding: 16px 24px;
            border-bottom: 1px solid rgba(138, 43, 226, 0.2);
            backdrop-filter: blur(10px);
        }

        .header-content {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .title {
            font-size: 20px;
            font-weight: 300;
            letter-spacing: 3px;
            color: #b19cd9;
        }

        .subtitle {
            font-size: 11px;
            color: rgba(126, 200, 227, 0.6);
            letter-spacing: 2px;
            margin-top: 2px;
        }

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .control-btn {
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.3);
            color: #b19cd9;
            padding: 6px 14px;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 12px;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        .control-btn:hover {
            background: rgba(138, 43, 226, 0.2);
            border-color: rgba(138, 43, 226, 0.5);
        }

        .control-btn.active {
            background: rgba(138, 43, 226, 0.3);
            color: #fff;
        }

        /* Timeline Viewport */
        .timeline-viewport {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #050511;
        }

        /* Time Axis - Clean and Minimal */
        .time-axis {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 32px;
            background: rgba(10, 10, 31, 0.6);
            border-bottom: 1px solid rgba(138, 43, 226, 0.15);
            z-index: 10;
        }

        .time-marker {
            position: absolute;
            top: 0;
            height: 100%;
            display: flex;
            align-items: center;
            padding: 0 12px;
            font-size: 10px;
            color: rgba(184, 134, 235, 0.5);
            font-weight: 400;
            letter-spacing: 0.5px;
            font-variant-numeric: tabular-nums;
        }

        .time-marker:first-child {
            color: rgba(184, 134, 235, 0.7);
        }

        /* Event Lanes */
        .event-lanes {
            position: absolute;
            top: 32px;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .event-lane {
            position: relative;
            height: 90px;
            border-bottom: 1px solid rgba(138, 43, 226, 0.08);
            overflow: visible;
        }

        .lane-label {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            font-weight: 500;
            color: rgba(184, 134, 235, 0.7);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            z-index: 5;
            background: rgba(5, 5, 17, 0.9);
            padding: 4px 10px;
            border-radius: 12px;
            border: 1px solid rgba(138, 43, 226, 0.15);
        }

        .lane-icon {
            display: inline-block;
            margin-right: 6px;
            font-size: 12px;
            opacity: 0.8;
        }

        /* Event Items - Clean Bubbles */
        .event-item {
            position: absolute;
            height: 60px;
            min-width: 60px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.5px;
            backdrop-filter: blur(10px);
            top: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .event-item-content {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
            text-align: center;
        }

        .event-item:hover {
            transform: translateY(-4px) scale(1.05);
            z-index: 100;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        /* Event Type Styles - Distinct Colors */
        .event-pulse {
            background: linear-gradient(135deg, #00b4d8, #0077b6);
            color: #ffffff;
        }

        .event-pulse:hover {
            box-shadow: 0 8px 24px rgba(0, 180, 216, 0.4);
        }

        .event-mode_shift {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: #ffffff;
        }

        .event-mode_shift:hover {
            box-shadow: 0 8px 24px rgba(155, 89, 182, 0.4);
        }

        .event-fault {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: #ffffff;
            animation: pulse-fault 3s infinite;
        }

        .event-fault:hover {
            box-shadow: 0 8px 24px rgba(231, 76, 60, 0.5);
        }

        @keyframes pulse-fault {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
        }

        .event-flux {
            background: linear-gradient(135deg, #f39c12, #d68910);
            color: #ffffff;
        }

        .event-flux:hover {
            box-shadow: 0 8px 24px rgba(243, 156, 18, 0.4);
        }

        .event-intervention {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: #ffffff;
        }

        .event-intervention:hover {
            box-shadow: 0 8px 24px rgba(39, 174, 96, 0.4);
        }

        /* Event Tooltip - Clean Design */
        .event-tooltip {
            position: absolute;
            background: rgba(17, 17, 34, 0.98);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 8px;
            padding: 16px;
            min-width: 260px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);
        }

        .event-tooltip.visible {
            opacity: 1;
        }

        .tooltip-header {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 12px;
            color: #b19cd9;
            letter-spacing: 0.5px;
        }

        .tooltip-content {
            font-size: 11px;
            line-height: 1.7;
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            padding: 3px 0;
        }

        .tooltip-label {
            color: rgba(184, 134, 235, 0.7);
            font-weight: 400;
        }

        .tooltip-value {
            color: #e0e0e0;
            font-weight: 500;
            font-variant-numeric: tabular-nums;
        }

        /* Current Time Indicator */
        .current-time-indicator {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(138, 43, 226, 0.8);
            z-index: 50;
            pointer-events: none;
            box-shadow: 0 0 12px rgba(138, 43, 226, 0.6);
        }

        .current-time-indicator::before {
            content: '';
            position: absolute;
            top: -6px;
            left: -5px;
            width: 12px;
            height: 12px;
            background: #8a2be2;
            border-radius: 50%;
            box-shadow: 0 0 16px rgba(138, 43, 226, 0.8);
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            background: rgba(10, 10, 31, 0.8);
            border: 1px solid rgba(138, 43, 226, 0.3);
            color: #b19cd9;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .zoom-btn:hover {
            background: rgba(138, 43, 226, 0.2);
            transform: scale(1.1);
        }

        /* Cognitive Load Graph */
        .cognitive-overlay {
            position: absolute;
            top: 32px;
            left: 0;
            right: 0;
            height: 100px;
            pointer-events: none;
            opacity: 0.4;
            z-index: 1;
        }

        /* Stats Panel - Streamlined */
        .stats-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 31, 0.9);
            border: 1px solid rgba(138, 43, 226, 0.2);
            border-radius: 8px;
            padding: 16px;
            min-width: 180px;
            z-index: 90;
            backdrop-filter: blur(20px);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 600;
            color: #b19cd9;
            font-variant-numeric: tabular-nums;
            line-height: 1;
        }

        .stat-label {
            font-size: 9px;
            color: rgba(184, 134, 235, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 4px;
        }

        /* View Mode Toggle */
        .view-toggle {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            background: rgba(10, 10, 31, 0.8);
            border-radius: 20px;
            padding: 4px;
            border: 1px solid rgba(138, 43, 226, 0.2);
            backdrop-filter: blur(10px);
        }

        .view-btn {
            padding: 6px 14px;
            background: transparent;
            border: none;
            color: rgba(184, 134, 235, 0.6);
            border-radius: 16px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.5px;
            transition: all 0.2s ease;
        }

        .view-btn.active {
            background: rgba(138, 43, 226, 0.3);
            color: #fff;
        }

        /* Loading State */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: rgba(184, 134, 235, 0.6);
            letter-spacing: 2px;
            font-weight: 300;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .stats-panel {
                display: none;
            }
            
            .lane-label {
                font-size: 9px;
                padding: 3px 8px;
            }
            
            .event-item {
                min-width: 48px;
                height: 48px;
                padding: 0 12px;
            }
        }
    </style>
</head>
<body>
    <div class="timeline-container">
        <!-- Header -->
        <div class="timeline-header">
            <div class="header-content">
                <div>
                    <h1 class="title">NEURAL COGNITION TIMELINE</h1>
                    <div class="subtitle">DAWN CONSCIOUSNESS MONITOR</div>
                </div>
                <div class="controls">
                    <button class="control-btn" id="pauseBtn">PAUSE</button>
                    <button class="control-btn" id="filterBtn">FILTERS</button>
                    <button class="control-btn" id="exportBtn">EXPORT</button>
                    <select id="timeRange" class="control-btn">
                        <option value="60">1 MIN</option>
                        <option value="300" selected>5 MIN</option>
                        <option value="900">15 MIN</option>
                        <option value="3600">1 HOUR</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Timeline Viewport -->
        <div class="timeline-viewport" id="timelineViewport">
            <div class="loading" id="loading">INITIALIZING...</div>
            
            <!-- Time Axis -->
            <div class="time-axis" id="timeAxis"></div>
            
            <!-- Cognitive Load Overlay -->
            <canvas class="cognitive-overlay" id="cognitiveCanvas"></canvas>
            
            <!-- Event Lanes -->
            <div class="event-lanes" id="eventLanes">
                <div class="event-lane" data-type="pulse">
                    <div class="lane-label">
                        <span class="lane-icon">⚡</span>PULSES
                    </div>
                </div>
                <div class="event-lane" data-type="mode_shift">
                    <div class="lane-label">
                        <span class="lane-icon">🔄</span>MODES
                    </div>
                </div>
                <div class="event-lane" data-type="fault">
                    <div class="lane-label">
                        <span class="lane-icon">⚠️</span>FAULTS
                    </div>
                </div>
                <div class="event-lane" data-type="flux">
                    <div class="lane-label">
                        <span class="lane-icon">📊</span>FLUX
                    </div>
                </div>
                <div class="event-lane" data-type="intervention">
                    <div class="lane-label">
                        <span class="lane-icon">🎛️</span>MODS
                    </div>
                </div>
            </div>
            
            <!-- Current Time Indicator -->
            <div class="current-time-indicator" id="currentTimeIndicator"></div>
            
            <!-- Event Tooltip -->
            <div class="event-tooltip" id="eventTooltip">
                <div class="tooltip-header" id="tooltipHeader"></div>
                <div class="tooltip-content" id="tooltipContent"></div>
            </div>
        </div>

        <!-- Zoom Controls -->
        <div class="zoom-controls">
            <button class="zoom-btn" id="zoomIn">+</button>
            <button class="zoom-btn" id="zoomOut">−</button>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="totalPulses">0</div>
                    <div class="stat-label">Pulses</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="cognitiveLoad">0%</div>
                    <div class="stat-label">Load</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="modeShifts">0</div>
                    <div class="stat-label">Shifts</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="coherence">0</div>
                    <div class="stat-label">Coherence</div>
                </div>
            </div>
        </div>

        <!-- View Mode Toggle -->
        <div class="view-toggle">
            <button class="view-btn active" id="neuralView">NEURAL</button>
            <button class="view-btn" id="rawView">RAW</button>
        </div>
    </div>

    <script>
        // Neural Cognition Timeline - Streamlined Implementation
        class NeuralCognitionTimeline {
            constructor() {
                this.events = [];
                this.timeRange = 300; // 5 minutes default
                this.currentTime = Date.now();
                this.zoom = 1;
                this.isPaused = false;
                this.viewMode = 'neural';
                
                this.cognitiveStates = ['introspective', 'analytical', 'expansive', 'adaptive', 'reflective', 'creative'];
                this.currentState = 'introspective';
                
                this.filters = {
                    pulse: true,
                    mode_shift: true,
                    fault: true,
                    flux: true,
                    intervention: true
                };
                
                this.initializeElements();
                this.setupEventListeners();
                this.startSimulation();
                this.startAnimation();
            }

            initializeElements() {
                this.viewport = document.getElementById('timelineViewport');
                this.timeAxis = document.getElementById('timeAxis');
                this.eventLanes = document.getElementById('eventLanes');
                this.currentTimeIndicator = document.getElementById('currentTimeIndicator');
                this.tooltip = document.getElementById('eventTooltip');
                this.cognitiveCanvas = document.getElementById('cognitiveCanvas');
                this.loading = document.getElementById('loading');
                
                this.cognitiveCtx = this.cognitiveCanvas.getContext('2d');
                this.resizeCanvas();
                
                setTimeout(() => {
                    this.loading.style.display = 'none';
                }, 1000);
            }

            setupEventListeners() {
                document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());
                document.getElementById('filterBtn').addEventListener('click', () => this.showFilterMenu());
                document.getElementById('exportBtn').addEventListener('click', () => this.exportData());
                document.getElementById('timeRange').addEventListener('change', (e) => {
                    this.timeRange = parseInt(e.target.value);
                    this.render();
                });
                
                document.getElementById('neuralView').addEventListener('click', () => this.setViewMode('neural'));
                document.getElementById('rawView').addEventListener('click', () => this.setViewMode('raw'));
                
                document.getElementById('zoomIn').addEventListener('click', () => this.adjustZoom(1.2));
                document.getElementById('zoomOut').addEventListener('click', () => this.adjustZoom(0.8));
                
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.viewport.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.adjustZoom(delta);
                });
            }

            startSimulation() {
                // Generate events at varying intervals
                const generateEvent = () => {
                    if (!this.isPaused) {
                        this.generateCognitiveEvent();
                    }
                    setTimeout(generateEvent, Math.random() * 3000 + 1000);
                };
                generateEvent();
                
                // Generate initial history
                const now = Date.now();
                for (let i = 0; i < 30; i++) {
                    const timestamp = now - Math.random() * this.timeRange * 1000;
                    this.generateCognitiveEvent(timestamp);
                }
            }

            generateCognitiveEvent(timestamp = Date.now()) {
                const eventTypes = ['pulse', 'mode_shift', 'fault', 'flux', 'intervention'];
                const weights = [0.45, 0.2, 0.05, 0.2, 0.1];
                
                const type = this.weightedRandom(eventTypes, weights);
                const event = this.createEvent(type, timestamp);
                
                this.events.push(event);
                
                // Keep events manageable
                const cutoffTime = Date.now() - (this.timeRange * 2 * 1000);
                this.events = this.events.filter(e => e.timestamp > cutoffTime);
                
                this.updateStats();
            }

            createEvent(type, timestamp) {
                const event = {
                    id: Math.random().toString(36).substr(2, 9),
                    type: type,
                    timestamp: timestamp,
                    duration: 80 + Math.random() * 120
                };

                switch (type) {
                    case 'pulse':
                        const patterns = ['α', 'β', 'γ', 'θ', 'δ'];
                        event.label = patterns[Math.floor(Math.random() * patterns.length)];
                        event.data = {
                            pattern: event.label,
                            frequency: 20 + Math.random() * 80,
                            intensity: Math.random()
                        };
                        break;
                        
                    case 'mode_shift':
                        const toState = this.cognitiveStates[Math.floor(Math.random() * this.cognitiveStates.length)];
                        event.label = toState.toUpperCase();
                        event.data = {
                            from: this.currentState,
                            to: toState,
                            trigger: 'neural cascade'
                        };
                        this.currentState = toState;
                        break;
                        
                    case 'fault':
                        const faults = ['LOOP', 'FRAGMENT', 'OVERFLOW', 'DESYNC'];
                        event.label = faults[Math.floor(Math.random() * faults.length)];
                        event.data = {
                            severity: 'high',
                            recovery: 500 + Math.random() * 1000
                        };
                        break;
                        
                    case 'flux':
                        const intensity = Math.floor(Math.random() * 100);
                        event.label = `${intensity}%`;
                        event.data = {
                            channel: 'neural load',
                            intensity: intensity
                        };
                        break;
                        
                    case 'intervention':
                        const actions = ['STABILIZE', 'AMPLIFY', 'DAMPEN', 'REALIGN'];
                        event.label = actions[Math.floor(Math.random() * actions.length)];
                        event.data = {
                            action: event.label,
                            magnitude: Math.random()
                        };
                        break;
                }

                return event;
            }

            weightedRandom(items, weights) {
                const total = weights.reduce((a, b) => a + b, 0);
                let random = Math.random() * total;
                
                for (let i = 0; i < items.length; i++) {
                    random -= weights[i];
                    if (random <= 0) return items[i];
                }
                return items[items.length - 1];
            }

            startAnimation() {
                const animate = () => {
                    if (!this.isPaused) {
                        this.currentTime = Date.now();
                        this.render();
                    }
                    requestAnimationFrame(animate);
                };
                animate();
            }

            render() {
                this.renderTimeAxis();
                this.renderEvents();
                this.renderCurrentTimeIndicator();
                this.renderCognitiveLoad();
            }

            renderTimeAxis() {
                this.timeAxis.innerHTML = '';
                
                const startTime = this.currentTime - this.timeRange * 1000;
                const interval = this.timeRange > 600 ? 60000 : 30000; // 1 min or 30 sec intervals
                
                // Calculate first tick time (rounded to interval)
                const firstTick = Math.ceil(startTime / interval) * interval;
                
                for (let time = firstTick; time <= this.currentTime; time += interval) {
                    const marker = document.createElement('div');
                    marker.className = 'time-marker';
                    marker.style.left = `${this.timeToPixel(time)}px`;
                    
                    // Format time cleanly
                    const date = new Date(time);
                    const seconds = date.getSeconds();
                    const timeStr = seconds === 0 ? 
                        date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }) :
                        date.toLocaleTimeString('en-US', { minute: '2-digit', second: '2-digit' });
                    
                    marker.textContent = timeStr;
                    this.timeAxis.appendChild(marker);
                }
            }

            renderEvents() {
                const lanes = this.eventLanes.querySelectorAll('.event-lane');
                
                lanes.forEach(lane => {
                    const type = lane.dataset.type;
                    const existingEvents = lane.querySelectorAll('.event-item');
                    existingEvents.forEach(e => e.remove());
                    
                    if (!this.filters[type]) return;
                    
                    const laneEvents = this.events.filter(e => e.type === type);
                    
                    laneEvents.forEach(event => {
                        const eventEl = this.createEventElement(event);
                        if (eventEl) lane.appendChild(eventEl);
                    });
                });
            }

            createEventElement(event) {
                const startTime = this.currentTime - this.timeRange * 1000;
                if (event.timestamp < startTime) return null;
                
                const el = document.createElement('div');
                el.className = `event-item event-${event.type}`;
                el.style.left = `${this.timeToPixel(event.timestamp)}px`;
                
                // Create content span
                const content = document.createElement('span');
                content.className = 'event-item-content';
                content.textContent = event.label || '';
                el.appendChild(content);
                
                // Event listeners
                el.addEventListener('mouseenter', (e) => this.showTooltip(event, e));
                el.addEventListener('mouseleave', () => this.hideTooltip());
                el.addEventListener('click', () => this.onEventClick(event));
                
                return el;
            }

            renderCurrentTimeIndicator() {
                this.currentTimeIndicator.style.left = `${this.timeToPixel(this.currentTime)}px`;
            }

            renderCognitiveLoad() {
                const ctx = this.cognitiveCtx;
                const width = this.cognitiveCanvas.width;
                const height = this.cognitiveCanvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                const fluxEvents = this.events
                    .filter(e => e.type === 'flux')
                    .sort((a, b) => a.timestamp - b.timestamp);
                
                if (fluxEvents.length < 2) return;
                
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, 'rgba(138, 43, 226, 0.3)');
                gradient.addColorStop(1, 'rgba(138, 43, 226, 0)');
                
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(138, 43, 226, 0.5)';
                ctx.lineWidth = 2;
                
                fluxEvents.forEach((event, index) => {
                    const x = this.timeToPixel(event.timestamp);
                    const y = height - (event.data.intensity / 100 * height);
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        const prevEvent = fluxEvents[index - 1];
                        const prevX = this.timeToPixel(prevEvent.timestamp);
                        const cpx = (prevX + x) / 2;
                        ctx.quadraticCurveTo(prevX, y, cpx, y);
                    }
                });
                
                ctx.stroke();
                
                // Fill
                ctx.lineTo(this.timeToPixel(fluxEvents[fluxEvents.length - 1].timestamp), height);
                ctx.lineTo(this.timeToPixel(fluxEvents[0].timestamp), height);
                ctx.closePath();
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            timeToPixel(timestamp) {
                const startTime = this.currentTime - this.timeRange * 1000;
                const progress = (timestamp - startTime) / (this.timeRange * 1000);
                return progress * this.viewport.offsetWidth * this.zoom;
            }

            showTooltip(event, mouseEvent) {
                const tooltip = this.tooltip;
                const header = document.getElementById('tooltipHeader');
                const content = document.getElementById('tooltipContent');
                
                header.textContent = event.type.replace('_', ' ').toUpperCase();
                
                let contentHtml = `
                    <div class="tooltip-row">
                        <span class="tooltip-label">Time</span>
                        <span class="tooltip-value">${new Date(event.timestamp).toLocaleTimeString()}</span>
                    </div>
                `;
                
                // Add type-specific content
                switch (event.type) {
                    case 'pulse':
                        contentHtml += `
                            <div class="tooltip-row">
                                <span class="tooltip-label">Pattern</span>
                                <span class="tooltip-value">${event.data.pattern} wave</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Frequency</span>
                                <span class="tooltip-value">${event.data.frequency.toFixed(1)} Hz</span>
                            </div>
                        `;
                        break;
                        
                    case 'mode_shift':
                        contentHtml += `
                            <div class="tooltip-row">
                                <span class="tooltip-label">From</span>
                                <span class="tooltip-value">${event.data.from}</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">To</span>
                                <span class="tooltip-value">${event.data.to}</span>
                            </div>
                        `;
                        break;
                        
                    case 'flux':
                        contentHtml += `
                            <div class="tooltip-row">
                                <span class="tooltip-label">Load</span>
                                <span class="tooltip-value">${event.data.intensity}%</span>
                            </div>
                        `;
                        break;
                }
                
                content.innerHTML = contentHtml;
                
                // Position tooltip
                const rect = mouseEvent.target.getBoundingClientRect();
                let top = rect.top - 80;
                let left = rect.left + rect.width / 2 - 130;
                
                if (top < 10) top = rect.bottom + 10;
                if (left < 10) left = 10;
                if (left + 260 > window.innerWidth) left = window.innerWidth - 270;
                
                tooltip.style.top = `${top}px`;
                tooltip.style.left = `${left}px`;
                tooltip.classList.add('visible');
            }

            hideTooltip() {
                this.tooltip.classList.remove('visible');
            }

            onEventClick(event) {
                console.log('Event clicked:', event);
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                const btn = document.getElementById('pauseBtn');
                btn.textContent = this.isPaused ? 'RESUME' : 'PAUSE';
                btn.classList.toggle('active', this.isPaused);
            }

            setViewMode(mode) {
                this.viewMode = mode;
                document.getElementById('neuralView').classList.toggle('active', mode === 'neural');
                document.getElementById('rawView').classList.toggle('active', mode === 'raw');
                this.render();
            }

            showFilterMenu() {
                alert('Filter menu - implement modal UI here');
            }

            exportData() {
                const data = {
                    events: this.events,
                    timeRange: this.timeRange,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `neural-timeline-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            adjustZoom(factor) {
                this.zoom = Math.max(0.5, Math.min(3, this.zoom * factor));
                this.render();
            }

            resizeCanvas() {
                this.cognitiveCanvas.width = this.viewport.offsetWidth;
                this.cognitiveCanvas.height = 100;
                this.render();
            }

            updateStats() {
                const pulseCount = this.events.filter(e => e.type === 'pulse').length;
                const shiftCount = this.events.filter(e => e.type === 'mode_shift').length;
                
                const recentFlux = this.events
                    .filter(e => e.type === 'flux' && e.timestamp > Date.now() - 60000)
                    .map(e => e.data.intensity);
                const avgLoad = recentFlux.length > 0 ? 
                    Math.round(recentFlux.reduce((a, b) => a + b, 0) / recentFlux.length) : 0;
                
                const coherence = 85 + Math.round(Math.random() * 10);
                
                document.getElementById('totalPulses').textContent = pulseCount;
                document.getElementById('modeShifts').textContent = shiftCount;
                document.getElementById('cognitiveLoad').textContent = `${avgLoad}%`;
                document.getElementById('coherence').textContent = coherence;
            }

            formatTime(timestamp) {
                return new Date(timestamp).toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            }
        }

        // Initialize
        const timeline = new NeuralCognitionTimeline();
        window.DAWNNeuralTimeline = timeline;
    </script>
</body>
</html>